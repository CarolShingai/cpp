# Ford-Johnson Algorithm (Merge-Insertion Sort)

O algoritmo Ford-Johnson, tamb√©m conhecido como **merge-insertion sort**, √© um algoritmo de ordena√ß√£o que minimiza o n√∫mero de compara√ß√µes necess√°rias. Ele foi desenvolvido por Lester R. Ford Jr. e Selmer M. Johnson em 1959.

## üìã Vis√£o Geral

O algoritmo combina as t√©cnicas de **merge sort** e **insertion sort** de forma inteligente:
1. **Fase de Emparelhamento**: Divide os elementos em pares e os ordena
2. **Fase de Separa√ß√£o**: Separa os elementos maiores e menores
3. **Fase de Ordena√ß√£o Recursiva**: Ordena recursivamente os elementos maiores
4. **Fase de Inser√ß√£o**: Insere os elementos menores usando a sequ√™ncia de Jacobsthal

## üî¢ Exemplo Ilustrativo

Vamos ordenar a sequ√™ncia: `[9, 3, 7, 1, 5, 8, 2, 6]`

### Passo 1: Emparelhamento e Ordena√ß√£o de Pares

```
Entrada: [9, 3, 7, 1, 5, 8, 2, 6]

Formamos pares:
(9, 3) ‚Üí (3, 9)  [menor, maior]
(7, 1) ‚Üí (1, 7)  [menor, maior]  
(5, 8) ‚Üí (5, 8)  [menor, maior]
(2, 6) ‚Üí (2, 6)  [menor, maior]
```

### Passo 2: Separa√ß√£o em Small e Big

```
Small: [3, 1, 5, 2]  (elementos menores de cada par)
Big:   [9, 7, 8, 6]  (elementos maiores de cada par)
```

### Passo 3: Ordena√ß√£o Recursiva do Big

O vetor **Big** `[9, 7, 8, 6]` √© ordenado recursivamente usando o mesmo processo:

```
Big: [9, 7, 8, 6]

Passo 3.1: Emparelhamento
(9, 7) ‚Üí (7, 9)
(8, 6) ‚Üí (6, 8)

Passo 3.2: Separa√ß√£o
Small_sub: [7, 6]
Big_sub:   [9, 8]

Passo 3.3: Ordena√ß√£o recursiva de Big_sub
Big_sub: [9, 8] ‚Üí [8, 9] (ordena√ß√£o direta)

Passo 3.4: Inser√ß√£o de Small_sub usando Jacobsthal
Big_sub = [8, 9]
Inserir 7: [7, 8, 9]
Inserir 6: [6, 7, 8, 9]

Resultado: Big = [6, 7, 8, 9]
```

### Passo 4: Inser√ß√£o Final usando Sequ√™ncia de Jacobsthal

Agora temos:
- **Big**: `[6, 7, 8, 9]` (ordenado)
- **Small**: `[3, 1, 5, 2]` (a ser inserido)

#### O que √© a Sequ√™ncia de Jacobsthal?

A sequ√™ncia de Jacobsthal √©: `1, 1, 3, 5, 11, 21, 43, 85, ...`

F√≥rmula: `J(n) = J(n-1) + 2*J(n-2)`, onde `J(0) = 1, J(1) = 1`

Para nosso exemplo com 4 elementos no Small, usamos: `[1, 3]`

#### Inser√ß√£o Ordenada

```
Big inicial: [6, 7, 8, 9]
Small:       [3, 1, 5, 2]  (√≠ndices: 0, 1, 2, 3)

Sequ√™ncia Jacobsthal para tamanho 4: [1, 3]

1. Inserir Small[1] = 1:
   [1, 6, 7, 8, 9]

2. Inserir Small[3] = 2:
   [1, 2, 6, 7, 8, 9]

3. Inserir elementos restantes (Small[2], Small[0]):
   Inserir Small[2] = 5: [1, 2, 5, 6, 7, 8, 9]
   Inserir Small[0] = 3: [1, 2, 3, 5, 6, 7, 8, 9]
```

## üéØ Por que a Sequ√™ncia de Jacobsthal?

A sequ√™ncia de Jacobsthal determina a **ordem √≥tima** para inser√ß√£o, minimizando o n√∫mero de compara√ß√µes necess√°rias durante a busca bin√°ria. Isso acontece porque:

1. **Balanceamento das Compara√ß√µes**: A sequ√™ncia garante que as √°rvores de decis√£o da busca bin√°ria sejam balanceadas
2. **Redu√ß√£o de Compara√ß√µes**: Evita compara√ß√µes desnecess√°rias ao inserir elementos em ordem estrat√©gica
3. **Otimalidade Matem√°tica**: Comprovadamente minimiza o n√∫mero total de compara√ß√µes

## üìä Complexidade

- **Tempo**: O(n log n) no pior caso, mas com **constante menor** que outros algoritmos
- **Espa√ßo**: O(n) para armazenamento auxiliar
- **Compara√ß√µes**: Pr√≥ximo ao limite te√≥rico m√≠nimo de compara√ß√µes

## üîß Implementa√ß√£o no Projeto

O projeto implementa o algoritmo Ford-Johnson para dois containers STL:

### std::vector
```cpp
void fordJohnsonVec();              // Fun√ß√£o principal
void fordJohnsonVecPairs();         // Emparelhamento
void fordJohnsonStep2();            // Ordena√ß√£o recursiva
void orderByJacobstallSeq_vec();    // Inser√ß√£o com Jacobsthal
```

### std::deque
```cpp
void fordJohnsonDeq();              // Fun√ß√£o principal  
void fordJohnsonDeqPairs();         // Emparelhamento
void fordJohnsonDeq2();             // Ordena√ß√£o recursiva
void orderByJacobstallSeq_deq();    // Inser√ß√£o com Jacobsthal
```

## üöÄ Como Usar

```bash
# Compilar
make

# Executar com n√∫meros positivos
./PmergeMe 9 3 7 1 5 8 2 6

# Sa√≠da esperada:
# before: 9 3 7 1 5 8 2 6
# after:  1 2 3 5 6 7 8 9
# Time to process a range of 8 elements with std::vector : X us
# Time to process a range of 8 elements with std::deque : Y us
```

## üìà Vantagens do Ford-Johnson

1. **N√∫mero M√≠nimo de Compara√ß√µes**: Teoricamente otimizado
2. **Estabilidade**: Mant√©m a ordem relativa de elementos iguais
3. **Adaptabilidade**: Funciona bem com diferentes tamanhos de entrada
4. **Eleg√¢ncia Matem√°tica**: Baseado em princ√≠pios matem√°ticos s√≥lidos

---

*Este algoritmo representa um marco na teoria da ordena√ß√£o, demonstrando como matem√°tica e algoritmos podem se combinar para criar solu√ß√µes elegantes e eficientes.*
